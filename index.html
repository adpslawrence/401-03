<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¥ç§˜è²“å’ªå®®æ®¿æ¢éšª</title>
    <!-- è¼‰å…¥ Tailwind CSS for layout -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ä½¿ç”¨å¾©å¤é¢¨æ ¼å­—é«” */
        @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');
        
        body {
            font-family: 'DotGothic16', monospace;
            background-color: #0d012e; /* ç¥ç§˜çš„æ·±è‰²èƒŒæ™¯ */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
        }

        .game-container {
            /* èª¿æ•´å®¹å™¨å¤§å°ä»¥ç¬¦åˆ 15x10 ç“·ç£š (40*15=600, 40*10=400) */
            width: 600px; 
            height: 400px;
            border: 8px solid #6b0f1a; /* å¾©å¤è¡€ç´…é‚Šæ¡† */
            box-shadow: 0 0 30px rgba(195, 47, 39, 0.6); /* è¼•å¾®çš„è¡€è‰²å…‰æšˆæ•ˆæœ */
            border-radius: 12px;
            overflow: hidden;
            background-color: #1b1b3a; /* éŠæˆ²å€èƒŒæ™¯ */
        }

        #gameCanvas {
            display: block;
            background-color: #0a0a20; /* æ¨¡æ“¬æ›´æ˜æš—å®®æ®¿çš„èƒŒæ™¯è‰² */
            cursor: default; /* ç§»é™¤æ»‘é¼ é»æ“Šæ¸¸æ¨™ */
        }

        .hud {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2rem;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #f1faee;
            border-radius: 8px;
            border: 2px solid #6b0f1a;
            z-index: 10;
        }

        .game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            padding: 30px;
            background: rgba(0, 0, 0, 0.95);
            color: #e9c46a;
            border: 4px solid #6b0f1a; /* è¡€è‰²é‚Šæ¡† */
            border-radius: 10px;
            z-index: 20;
            min-width: 300px;
        }

        .game-message h1 {
            font-size: 2.5rem;
            margin-bottom: 1rem;
            color: #c32f27; /* è¡€ç´…æ¨™é¡Œ */
            text-shadow: 2px 2px #000;
        }

        .game-message p {
            font-size: 1.2rem;
            margin-bottom: 2rem;
        }
        
        /* æ–°å¢æ“ä½œèªªæ˜ */
        .controls-text {
            font-size: 1rem;
            color: #a3b18a;
            margin-top: 1rem;
        }

        .start-button, .retry-button {
            padding: 10px 20px;
            font-size: 1.5rem;
            cursor: pointer;
            background-color: #e76f51;
            color: #1b1b3a;
            border: 3px solid #c32f27;
            border-radius: 6px;
            transition: transform 0.1s;
        }

        .start-button:hover, .retry-button:hover {
            background-color: #c32f27;
            color: white;
            transform: scale(1.05);
        }
        
        .cat-visual {
            font-size: 48px; /* è²“å’ªå¤§å° */
            /* è®“è²“å’ªåœ¨ç§»å‹•æ™‚æœ‰è¼•å¾®çš„å‹•ç•«æ„Ÿ */
            animation: cat-move 0.5s infinite alternate;
        }

        @keyframes cat-move {
            from { transform: translateY(0px); }
            to { transform: translateY(-5px); }
        }

        /* éŸ¿æ‡‰å¼èª¿æ•´ */
        @media (max-width: 640px) {
            .game-container {
                width: 100%;
                max-width: 90vw;
            }
            .game-message h1 {
                font-size: 2rem;
            }
            .game-message p {
                font-size: 1rem;
            }
            .hud {
                gap: 1rem;
            }
        }
    </style>
</head>
<body>

    <div class="game-container relative">
        <!-- ä¿®æ­£ 3: å°‡æ‰€æœ‰ç‹€æ…‹é¡¯ç¤ºç§»è‡³æœ€ä¸Šæ–¹ HUD -->
        <div class="hud" id="hud">
            <!-- HP Display with Visual Bar -->
            <div class="flex flex-col items-start min-w-[120px]">
                <div class="text-sm font-bold text-white mb-1">HP: <span id="hpValue">100</span></div>
                <div class="w-full h-3 bg-gray-700 rounded-full overflow-hidden">
                    <div id="hpBar" class="h-full bg-green-500 transition-all duration-300" style="width: 100%;"></div>
                </div>
            </div>
            
            <!-- Score and Level Display (ä¿®æ­£ 1: å¢åŠ æƒ¡é¬¼æ•¸é‡å›é¥‹)-->
            <div id="scoreDisplay" class="text-right">
                å°é­š: 0<br>
                æƒ¡é¬¼: 0<br>
                é—œå¡: 1/10
            </div>
        </div>

        <canvas id="gameCanvas" width="600" height="400"></canvas>

        <div class="game-message" id="messageScreen">
            <h1>ç¥ç§˜è²“å’ªå®®æ®¿è¿·å®®æ¢éšª</h1>
            <p>
                ä¸»è§’æ˜¯ä¸€éš»å°ç°è²“ï¼Œèº«è™•å……æ»¿æƒ¡é¬¼å’Œè‡´å‘½é™·é˜±çš„ç¥ç§˜è¿·å®®ã€‚<br>
                ç›®æ¨™ï¼š**æ¸…é™¤æ‰€æœ‰æ•µäººåŠå°é­šï¼Œå®Œæˆæ‰€æœ‰ 10 å€‹é—œå¡ï¼**<br>
                âœ¨ åƒåˆ°å°é­š **(+50 åˆ†)** å¯ä»¥å‡ç´šä¸¦æ¢å¾©ç”Ÿå‘½ã€‚<br>
                ğŸ‘¹ ç¢°åˆ°æƒ¡é¬¼æœƒæŒçºŒæè¡€ï¼ **ğŸ”¥ è¸©åˆ°é™·é˜±æœƒå—åˆ°é‡å‰µ (-30 HP) ä¸¦ä½¿é™·é˜±æ¶ˆå¤±ï¼**
            </p>
            <!-- ç§»é™¤ inline onclick, æ”¹ç”¨ id é€é JS ç¶å®š -->
            <button class="start-button" id="startButton">Start Game</button>
            <!-- ä¿®æ­£ 2: æ“ä½œèªªæ˜æ”¹ç‚ºåªé¡¯ç¤ºæ–¹å‘éµ -->
            <p class="controls-text">æ“ä½œï¼š**æ–¹å‘éµç§»å‹•** | **ç©ºç™½éµæ”»æ“Š**</p>
        </div>
    </div>

    <script>
        // å…¨å±€è®Šæ•¸ç”¨æ–¼ Firebase
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;

        // ============== éŠæˆ²è¨­å®šèˆ‡åˆå§‹åŒ– ==============
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const messageScreen = document.getElementById('messageScreen');
        const hud = document.getElementById('hud');
        // ä¿®æ­£ 3: ç²å– HTML è£¡çš„ HP é¡¯ç¤ºå…ƒç´ 
        const hpValue = document.getElementById('hpValue');
        const hpBar = document.getElementById('hpBar');
        const scoreDisplay = document.getElementById('scoreDisplay');

        // è¿·å®®èˆ‡ç¶²æ ¼è¨­å®š (Canvas: 600x400)
        const TILE_SIZE = 40; 
        const COLS = canvas.width / TILE_SIZE; // 15
        const ROWS = canvas.height / TILE_SIZE; // 10

        // è¿·å®®ä½ˆå±€ (1=ç‰†å£ Wall, 0=é“è·¯ Path) - å›ºå®šä½¿ç”¨æ­¤ä½ˆå±€ä½œç‚ºæ‰€æœ‰é—œå¡çš„åœ°åœ–çµæ§‹
        const mazeLayout = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
            [1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1],
            [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        let gameState = 'START'; // START, PLAYING, GAME_OVER, WIN
        let currentLevel = 1; // ç›®å‰é—œå¡
        const MAX_LEVELS = 10; // ç¸½é—œå¡æ•¸
        let cat = {};
        let fish = [];
        let enemies = [];
        let traps = []; 
        // ç§»é™¤å¯¶è—ç‰©ä»¶ treasure
        let score = 0;
        let enemyIntervalId = null; 
        
        // æ”»æ“Šç›¸é—œç‹€æ…‹
        let isAttacking = false;
        const attackDuration = 200; // æ”»æ“ŠæŒçºŒæ™‚é–“ (æ¯«ç§’)
        const attackRange = 1.5; // æ”»æ“Šç¯„åœ (æ ¼ç‹€éŠæˆ²ä¸­ï¼ŒåŠå¾‘ 1.5 æ„å‘³è‘—æ”»æ“Šæ‰€æœ‰ç›¸é„°æ ¼å­)

        // è¼”åŠ©å‡½æ•¸ï¼šå°‡ç¶²æ ¼åº§æ¨™è½‰æ›ç‚ºåƒç´ ä¸­å¿ƒåº§æ¨™
        function gridToPixel(col, row) {
            return {
                x: col * TILE_SIZE + TILE_SIZE / 2,
                y: row * TILE_SIZE + TILE_SIZE / 2
            };
        }

        // è¼”åŠ©å‡½æ•¸ï¼šéš¨æ©Ÿç”Ÿæˆåœ¨é“è·¯ä¸Šçš„ç¶²æ ¼ä½ç½®
        function getRandomPathPosition() {
            let col, row;
            do {
                col = Math.floor(Math.random() * COLS);
                row = Math.floor(Math.random() * ROWS);
            } while (mazeLayout[row][col] === 1); // ç¢ºä¿åªåœ¨é“è·¯ä¸Š (0)

            return { col, row, ...gridToPixel(col, row) };
        }

        // è¼‰å…¥ç‰¹å®šé—œå¡
        function loadLevel(level) {
            currentLevel = level;
            
            // è²“å’ªåˆå§‹ä½ç½®èˆ‡å±¬æ€§ (å¿…é ˆæ˜¯é“è·¯)
            cat = {
                ...getRandomPathPosition(),
                radius: 15, // åƒ…ç”¨æ–¼ç¹ªåœ–
                // é€²å…¥æ–°é—œå¡æ™‚ï¼ŒHP ä¿æŒä¸è®Šï¼Œè‹¥ç‚ºç¬¬ä¸€é—œå‰‡è¨­ç‚º 100
                hp: cat.hp === undefined || level === 1 ? 100 : Math.min(100, cat.hp),
            };
            
            // ç”±æ–¼ç§»é™¤å¯¶è—ï¼Œä¸å†éœ€è¦å¯¶è—çš„åˆå§‹ä½ç½®è¨­å®š
            
            // é›£åº¦èª¿æ•´: éš¨è‘—é—œå¡æ•¸å¢åŠ æ•µäººèˆ‡é™·é˜±
            const baseFish = 15;
            const baseEnemies = 15;
            const baseTraps = 5;

            // èª¿æ•´é›£åº¦: æ¯ 10 é—œå¢åŠ  50% æ•µäººï¼Œæ¯ 20 é—œå¢åŠ  100% é™·é˜±
            // ç”±æ–¼åªæœ‰ 10 é—œï¼Œæ•µäººå’Œé™·é˜±æ•¸é‡å¢é•·æœƒè¼ƒç‚ºå¹³ç·©
            const enemyMultiplier = 1 + Math.floor(level / 5) * 0.5;
            const trapMultiplier = 1 + Math.floor(level / 10) * 1.0;
            
            const numFish = baseFish; 
            // æ•µäººä¸Šé™ 60
            const numEnemies = Math.min(60, Math.floor(baseEnemies * enemyMultiplier)); 
            // é™·é˜±ä¸Šé™ 20
            const numTraps = Math.min(20, Math.floor(baseTraps * trapMultiplier)); 

            // éš¨æ©Ÿç”ŸæˆéŠæˆ²ç‰©ä»¶ (é­š)
            fish = [];
            for (let i = 0; i < numFish; i++) {
                // ç¢ºä¿é­šä¸èˆ‡è²“å’ªåˆå§‹ä½ç½®é‡ç–Š
                let pos;
                do {
                    pos = getRandomPathPosition();
                } while (pos.col === cat.col && pos.row === cat.row);
                fish.push({ ...pos, type: 'ğŸŸ' });
            }

            // éš¨æ©Ÿç”ŸæˆéŠæˆ²ç‰©ä»¶ (æ•µäºº)
            enemies = [];
            for (let i = 0; i < numEnemies; i++) {
                // ç¢ºä¿æ•µäººä¸èˆ‡è²“å’ªåˆå§‹ä½ç½®é‡ç–Š
                let pos;
                do {
                    pos = getRandomPathPosition();
                } while (pos.col === cat.col && pos.row === cat.row);

                enemies.push({ 
                    ...pos, 
                    type: 'ğŸ‘¹', 
                });
            }

            // éš¨æ©Ÿç”Ÿæˆé™·é˜±
            traps = [];
            for (let i = 0; i < numTraps; i++) {
                let trapPos;
                let isOverlapping;
                
                // ç¢ºä¿é™·é˜±ä¸èˆ‡è²“å’ªã€æˆ–ç¾æœ‰é™·é˜±é‡ç–Š (å·²ç§»é™¤å°å¯¶è—çš„æª¢æŸ¥)
                do {
                    trapPos = getRandomPathPosition();
                    isOverlapping = (trapPos.col === cat.col && trapPos.row === cat.row); 

                    if (!isOverlapping) {
                        // æª¢æŸ¥æ˜¯å¦èˆ‡ç¾æœ‰é™·é˜±é‡ç–Š
                        for (const t of traps) {
                            if (t.col === trapPos.col && t.row === trapPos.row) {
                                isOverlapping = true;
                                break;
                            }
                        }
                    }
                    
                } while (isOverlapping);

                traps.push({ 
                    col: trapPos.col, 
                    row: trapPos.row, 
                    x: trapPos.x, 
                    y: trapPos.y, 
                    type: 'ğŸ”¥', // ç«ç„°é™·é˜±è¦–è¦ºæ•ˆæœ
                    damage: 30 // é™·é˜±å‚·å®³æå‡è‡³ 30
                });
            }
        }
        
        // è™•ç†éµç›¤äº‹ä»¶ (ç§»å‹•èˆ‡æ”»æ“Š)
        function handleKeyDown(event) {
            if (gameState !== 'PLAYING') return;
            
            let newCol = cat.col;
            let newRow = cat.row;
            
            // è™•ç†ç§»å‹•éµ (ä¿®æ­£ 2: åƒ…ä½¿ç”¨æ–¹å‘éµ)
            if (event.key === 'ArrowUp') newRow--;
            else if (event.key === 'ArrowDown') newRow++;
            else if (event.key === 'ArrowLeft') newCol--;
            else if (event.key === 'ArrowRight') newCol++;
            
            // è™•ç†æ”»æ“Šéµ
            else if (event.code === 'Space' && !isAttacking) {
                isAttacking = true;
                // è¨­å®šæ”»æ“ŠæŒçºŒæ™‚é–“å¾Œï¼Œé—œé–‰æ”»æ“Šç‹€æ…‹
                setTimeout(() => {
                    isAttacking = false;
                }, attackDuration);
                // åŸ·è¡Œæ”»æ“Šç¢°æ’æª¢æŸ¥
                checkAttackCollision(); 
                draw(); // å¼·åˆ¶é‡ç¹ªæ”»æ“Šæ•ˆæœ
                return; // æ”»æ“Šä¸å½±éŸ¿ç§»å‹•
            }
            else return; // å¿½ç•¥å…¶ä»–éµ

            // æª¢æŸ¥æ˜¯å¦åˆæ³•ç§»å‹•ï¼šé‚Šç•Œæª¢æŸ¥ && éç‰†å£æª¢æŸ¥
            if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < COLS && mazeLayout[newRow][newCol] === 0) {
                // ç§»å‹•è²“å’ª
                cat.col = newCol;
                cat.row = newRow;
                // æ›´æ–°åƒç´ åº§æ¨™ (ç”¨æ–¼ç¹ªåœ–)
                const newPos = gridToPixel(newCol, newRow);
                cat.x = newPos.x;
                cat.y = newPos.y;
            }
            
            // ç§»å‹•å¾Œç«‹å³æª¢æŸ¥ç¢°æ’ (é­š/å¯¶è—/æ•µäºº/é™·é˜±)
            checkCollisions(); 
        }
        
        // é€²å…¥ä¸‹ä¸€é—œ
        function nextLevel() {
            gameState = 'PLAYING';
            messageScreen.style.display = 'none';
            hud.style.display = 'flex';
            loadLevel(currentLevel);
        }

        // éŠæˆ²åˆå§‹åŒ–ï¼ˆå¾ Start Game æŒ‰éˆ•èª¿ç”¨ï¼‰
        function initGame() {
            console.log("Game initialized!"); // ç¢ºèªå‡½æ•¸æ˜¯å¦è¢«èª¿ç”¨
            if (enemyIntervalId) clearInterval(enemyIntervalId);
            score = 0; // é‡æ–°é–‹å§‹éŠæˆ²ï¼Œåˆ†æ•¸æ­¸é›¶
            currentLevel = 1; // å¾ç¬¬ä¸€é—œé–‹å§‹
            loadLevel(currentLevel);
            gameState = 'PLAYING';
            messageScreen.style.display = 'none';
            hud.style.display = 'flex';
            
            // ç§»é™¤æ»‘é¼ é»æ“Šäº‹ä»¶ (ä¸å†ä½¿ç”¨)
            canvas.removeEventListener('click', handleCanvasClick); 
            // ç¶å®šéµç›¤äº‹ä»¶ (ç§»å‹•èˆ‡æ”»æ“Š)
            window.addEventListener('keydown', handleKeyDown);

            // å•Ÿå‹•æ•µäººç§»å‹•è¨ˆæ™‚å™¨ (æ¯ 400ms ç§»å‹•ä¸€æ¬¡ï¼Œé€Ÿåº¦æ›´å¿«)
            enemyIntervalId = setInterval(updateEnemyMovement, 400);

            // å•Ÿå‹•éŠæˆ²ä¸»å¾ªç’° (åªè² è²¬ç¹ªåœ–å’Œç‹€æ…‹æª¢æŸ¥)
            requestAnimationFrame(gameLoop);
        }
        
        // ç§»é™¤äº‹ä»¶ç›£è½å™¨å’Œè¨ˆæ™‚å™¨
        function removeGameListeners() {
            window.removeEventListener('keydown', handleKeyDown);
            if (enemyIntervalId) clearInterval(enemyIntervalId);
            enemyIntervalId = null;
        }

        // (ç©ºå‡½æ•¸ï¼Œè¿·å®®æ¨¡å¼ä¸å†ä½¿ç”¨æ»‘é¼ ç§»å‹•)
        function handleCanvasClick() {} 

        // ============== ç¹ªè£½å‡½æ•¸ ==============
        function drawMaze() {
            ctx.fillStyle = '#6b5e50'; // ç‰†å£é¡è‰² (æœ¨é ­/çŸ³æ)
            ctx.strokeStyle = '#a3b18a';
            ctx.lineWidth = 2;
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (mazeLayout[r][c] === 1) {
                        // ç¹ªè£½ç‰†å£
                        ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        ctx.strokeRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }
                }
            }
        }

        function drawCat() {
            ctx.font = '48px DotGothic16';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ğŸ±', cat.x, cat.y);
            
            // æ–°å¢ï¼šç¹ªè£½æ”»æ“Šæ•ˆæœ
            if (isAttacking) {
                ctx.save();
                ctx.translate(cat.x, cat.y);
                
                // ç¹ªè£½ä»£è¡¨çˆªæ“Šçš„ç°¡å–®ç™½è‰²åœ“å½¢/å…‰æšˆ (åŠå¾‘ 1.5 å€ TILE_SIZEï¼Œè¶³ä»¥è¦†è“‹å‘¨åœ 8 æ ¼)
                ctx.beginPath();
                ctx.arc(0, 0, TILE_SIZE * attackRange, 0, 2 * Math.PI); 
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)'; // ç™½è‰²åŠé€æ˜
                ctx.fill();
                ctx.restore();
            }
        }

        function drawObjects() {
            // ç¹ªè£½é­š
            ctx.font = '28px DotGothic16';
            fish.forEach(f => {
                ctx.fillText(f.type, f.x, f.y);
            });

            // ç¹ªè£½æ•µäºº (æƒ¡é¬¼)
            ctx.font = '36px DotGothic16'; // ç¨å¾®æ”¾å¤§
            enemies.forEach(e => {
                ctx.fillText(e.type, e.x, e.y);
            });
            
            // ç¹ªè£½é™·é˜± (æ–°å¢)
            ctx.font = '30px DotGothic16';
            traps.forEach(t => {
                ctx.fillText(t.type, t.x, t.y);
            });

            // å¯¶è—å·²è¢«ç§»é™¤ï¼Œä¸å†ç¹ªè£½
            // ctx.font = '40px DotGothic16';
            // ctx.fillText(treasure.type, treasure.x, treasure.y);
        }

        function drawJapanesePalaceOverlay() {
            // æ¨¡æ“¬å¾®å¼±ä¸”ææ€–çš„ç’°å¢ƒå…‰ - é›†ä¸­åœ¨è²“å’ªå‘¨åœ
            const catPixelPos = gridToPixel(cat.col, cat.row);
            let gradient = ctx.createRadialGradient(catPixelPos.x, catPixelPos.y, 50, catPixelPos.x, catPixelPos.y, 300);
            gradient.addColorStop(0, 'rgba(238, 174, 202, 0.2)'); // è²“å’ªå‘¨åœå¾®å¼±çš„å…‰
            gradient.addColorStop(0.5, 'rgba(44, 62, 80, 0.7)'); // æ¿ƒé‡çš„é™°å½±
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.9)'); // é‚Šç·£å®Œå…¨é»‘æš—
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // ä¿®æ­£ 3: ç§»é™¤äº†åœ¨ Canvas ä¸Šç¹ªè£½ HP æ¢çš„é‚è¼¯ï¼Œæ”¹ç‚ºæ›´æ–° HTML å…ƒç´ 
        function drawHUD() {
            // ç¢ºä¿ cat.hp ä¸å°æ–¼ 0
            const currentHp = Math.max(0, cat.hp);
            const healthRatio = currentHp / 100;

            // æ›´æ–° HP æ•¸å­—é¡¯ç¤º
            hpValue.textContent = currentHp;

            // æ›´æ–° HP æ¢æ¨£å¼
            hpBar.style.width = `${healthRatio * 100}%`;
            
            // æ ¹æ“š HP æ¯”ä¾‹æ”¹è®Šé¡è‰²
            let colorClass = 'bg-green-500';
            if (healthRatio <= 0.5) {
                colorClass = 'bg-yellow-500';
            }
            if (healthRatio <= 0.2) {
                colorClass = 'bg-red-500';
            }
            // ç§»é™¤æ‰€æœ‰èˆŠé¡è‰²é¡åˆ¥ä¸¦æ·»åŠ æ–°é¡è‰²
            hpBar.className = `h-full ${colorClass} transition-all duration-300`;


            // æ›´æ–°åˆ†æ•¸ã€æ•µäººæ•¸é‡å’Œé—œå¡é¡¯ç¤º (ä¿®æ­£ 1: å¢åŠ æƒ¡é¬¼æ•¸é‡)
            scoreDisplay.innerHTML = `å°é­š: ${score}<br>æƒ¡é¬¼: ${enemies.length}<br>é—œå¡: ${currentLevel}/${MAX_LEVELS}`;
        }
        
        // æ¸²æŸ“æ‰€æœ‰éŠæˆ²å…ƒç´ 
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawMaze(); // ç¹ªè£½è¿·å®®ç‰†å£
            drawJapanesePalaceOverlay(); // æ‡‰ç”¨é»‘æš—å…‰æšˆæ•ˆæœ
            drawObjects();
            drawCat();
            drawHUD(); // ç¢ºä¿ HUD æ°¸é åœ¨é ‚å±¤
        }

        // ============== éŠæˆ²é‚è¼¯æ›´æ–° ==============

        // æ•µäººè¡Œå‹• (æ¯éš” 400ms åŸ·è¡Œä¸€æ¬¡)
        function updateEnemyMovement() {
            if (gameState !== 'PLAYING') return; // ç¢ºä¿åœ¨éŠæˆ²ä¸­æ‰ç§»å‹•
            
            enemies.forEach(e => {
                const possibleMoves = [
                    { dc: 0, dr: -1 }, // Up
                    { dc: 0, dr: 1 },  // Down
                    { dc: -1, dr: 0 }, // Left
                    { dc: 1, dr: 0 }   // Right
                ];
                
                // éš¨æ©Ÿé¸æ“‡ä¸€å€‹ç§»å‹•æ–¹å‘
                const move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                
                const newCol = e.col + move.dc;
                const newRow = e.row + move.dr;

                // æª¢æŸ¥æ˜¯å¦å¯ä»¥ç§»å‹• (é‚Šç•Œå’Œéç‰†å£)
                if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < COLS && mazeLayout[newRow][newCol] === 0) {
                    e.col = newCol;
                    e.row = newRow;
                    const newPos = gridToPixel(newCol, newRow);
                    e.x = newPos.x;
                    e.y = newPos.y;
                }
            });
            // æ•µäººç§»å‹•å¾Œï¼Œæª¢æŸ¥æ˜¯å¦èˆ‡è²“å’ªç™¼ç”Ÿç¢°æ’
            checkCollisions();
        }
        
        // æª¢æŸ¥è²“å’ªæ”»æ“Šèˆ‡æ•µäººçš„ç¢°æ’
        function checkAttackCollision() {
            let enemiesToKeep = [];
            
            // æ”»æ“Šç¯„åœæª¢æŸ¥ (æ”»æ“Šæ‰€æœ‰ç›¸é„°çš„ 8 æ ¼ï¼ŒåŒ…æ‹¬æ–œè§’)
            const attackCols = [cat.col - 1, cat.col, cat.col + 1];
            const attackRows = [cat.row - 1, cat.row, cat.row + 1];

            enemies.forEach(e => {
                // æª¢æŸ¥æ•µäººçš„æ ¼å­æ˜¯å¦åœ¨è²“å’ªçš„æ”»æ“Šç¯„åœå…§
                if (attackCols.includes(e.col) && attackRows.includes(e.row) && (e.col !== cat.col || e.row !== cat.row)) {
                    // æ•µäººè¢«æ“Šä¸­ï¼Œå¾å ´æ™¯ç§»é™¤
                    score += 50; // æ“Šæ•—æ•µäººçå‹µåˆ†æ•¸
                } else {
                    enemiesToKeep.push(e);
                }
            });
            enemies = enemiesToKeep;
            
            // æ¯æ¬¡æ”»æ“Šå¾Œï¼Œæª¢æŸ¥éŠæˆ²å‹åˆ©æ¢ä»¶ (å› ç‚ºå¯èƒ½æœƒæ¸…å…‰æ•µäºº)
            checkGameOverConditions();
        }

        function checkCollisions() {
            // 1. æª¢æŸ¥è²“å’ªèˆ‡é­šçš„ç¢°æ’ (åœ¨åŒä¸€æ ¼)
            fish = fish.filter(f => {
                if (f.col === cat.col && f.row === cat.row) {
                    // åƒåˆ°å°é­š
                    score += 50; // 50 é»åˆ†æ•¸
                    if (score % 100 === 0) {
                        cat.hp = Math.min(100, cat.hp + 20); // å‡ç´š/å›è¡€
                    }
                    return false; // ç§»é™¤è¢«åƒçš„é­š
                }
                return true;
            });
            
            // 2. æª¢æŸ¥è²“å’ªèˆ‡æ•µäººçš„ç¢°æ’ (æŒçºŒå‚·å®³ - åœ¨åŒä¸€æ ¼)
            enemies.forEach(e => {
                if (e.col === cat.col && e.row === cat.row) {
                    // ç¢°åˆ°æ•µäººï¼Œæ‰£è¡€
                    cat.hp -= 5; 
                }
            });
            
            // 3. æª¢æŸ¥è²“å’ªèˆ‡é™·é˜±çš„ç¢°æ’ (ä¿®æ­£: è¸©åˆ°å¾Œé™·é˜±æ¶ˆå¤±)
            traps = traps.filter(t => {
                if (t.col === cat.col && t.row === cat.row) {
                    // è¸©åˆ°é™·é˜±ï¼Œæ‰£è¡€
                    cat.hp -= 30; 
                    // é™·é˜±æ¶ˆå¤± (è¿”å› false)
                    return false; 
                }
                return true; // ä¿ç•™æœªè¸©åˆ°çš„é™·é˜±
            });


            // 4. å¯¶è—åŠŸèƒ½å·²ç§»é™¤ï¼Œä¸å†æª¢æŸ¥ç¢°æ’

            // 5. æª¢æŸ¥ HP æ˜¯å¦æ­¸é›¶
            if (cat.hp <= 0) {
                gameState = 'GAME_OVER';
            }

            // æ¯æ¬¡ç¢°æ’æª¢æŸ¥å¾Œï¼Œæª¢æŸ¥éŠæˆ²ç‹€æ…‹
            checkGameOverConditions();
        }

        function checkGameOverConditions() {
            // æ–°å¢å‹åˆ©æ¢ä»¶æª¢æŸ¥: ç•¶æ‰€æœ‰é­šå’Œæ•µäººéƒ½è¢«æ¸…é™¤æ™‚ï¼Œè¦–ç‚ºé—œå¡å®Œæˆ
            if (gameState === 'PLAYING' && fish.length === 0 && enemies.length === 0) {
                 gameState = 'WIN'; // è¨­å®šç‚ºå‹åˆ©ç‹€æ…‹
            }

            if (gameState === 'GAME_OVER') {
                displayMessage('éŠæˆ²çµæŸ', `è²“å’ªè¢«æƒ¡é¬¼æˆ–é™·é˜±æ“Šå€’äº†ï¼æ‚¨æ’åˆ°äº†ç¬¬ ${currentLevel} é—œã€‚ç¸½åˆ†: ${score}`, 'é‡æ–°é–‹å§‹', initGame);
                removeGameListeners();
            } else if (gameState === 'WIN') {
                if (currentLevel < MAX_LEVELS) {
                    currentLevel++;
                    displayMessage('é—œå¡å®Œæˆï¼', `æ­å–œæ‚¨ï¼æ‰€æœ‰æ•µäººå·²æ¸…é™¤ï¼Œé€²å…¥ç¬¬ ${currentLevel} é—œï¼`, 'ç¹¼çºŒæ¢éšª', nextLevel);
                } else {
                    displayMessage('æœ€çµ‚å‹åˆ©ï¼', `æ‚¨æˆåŠŸå®Œæˆäº†æ‰€æœ‰ ${MAX_LEVELS} å€‹é—œå¡çš„æ¸…æƒä»»å‹™ï¼Œé€ƒå‡ºäº†é»‘æš—å®®æ®¿ï¼ç¸½åˆ†: ${score}`, 'å†ç©ä¸€æ¬¡', initGame);
                    removeGameListeners();
                }
            }
        }

        // ============== è¨Šæ¯é¡¯ç¤ºèˆ‡æ§åˆ¶ ==============
        // é€šç”¨è¨Šæ¯é¡¯ç¤ºå‡½æ•¸
        function displayMessage(title, message, buttonText, actionFunction) {
            messageScreen.innerHTML = `
                <h1>${title}</h1>
                <p>${message}</p>
                <button class="retry-button" id="actionButton">${buttonText}</button>
                <!-- ä¿®æ­£ 2: æ“ä½œèªªæ˜æ”¹ç‚ºåªé¡¯ç¤ºæ–¹å‘éµ -->
                <p class="controls-text">æ“ä½œï¼š**æ–¹å‘éµç§»å‹•** | **ç©ºç™½éµæ”»æ“Š**</p>
            `;
            
            // ç¶å®šå‹•æ…‹çš„ onclick äº‹ä»¶
            document.getElementById('actionButton').onclick = actionFunction;
            
            messageScreen.style.display = 'block';
            hud.style.display = 'none';
        }


        // ============== éŠæˆ²ä¸»å¾ªç’° ==============
        function gameLoop() {
            if (gameState === 'PLAYING') {
                // åœ¨è¿·å®®æ¨¡å¼ä¸‹ï¼Œç§»å‹•é‚è¼¯ç”± handleKeyDown å’Œ setInterval é©…å‹•ï¼Œä¸»å¾ªç’°åªè² è²¬ç¹ªåœ–
                draw();
                
                requestAnimationFrame(gameLoop);
            }
        }

        // é¦–æ¬¡è¼‰å…¥æ™‚ï¼Œåªé¡¯ç¤º Start Game ç•«é¢
        window.onload = function() {
            // ç¢ºä¿ cat å°è±¡åœ¨ drawJapanesePalaceOverlay é¦–æ¬¡èª¿ç”¨æ™‚å­˜åœ¨
            loadLevel(currentLevel); 
            
            messageScreen.style.display = 'block';
            hud.style.display = 'none';
            // ç¹ªè£½åˆå§‹ç©ºçš„ç•«å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0a0a20'; // ä½¿ç”¨æ–°çš„æ·±è‰²èƒŒæ™¯
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ä¿®æ­£ 3: æ‰‹å‹•æ›´æ–° HUD å…ƒç´ ä»¥åæ˜ åˆå§‹ç‹€æ…‹
            const initialScore = 0;
            const initialEnemies = 0;
            const initialLevel = 1;

            if (hpBar) {
                hpBar.style.width = `100%`;
                hpBar.className = `h-full bg-green-500 transition-all duration-300`;
            }
            if (hpValue) hpValue.textContent = 100;
            if (scoreDisplay) scoreDisplay.innerHTML = `å°é­š: ${initialScore}<br>æƒ¡é¬¼: ${initialEnemies}<br>é—œå¡: ${initialLevel}/${MAX_LEVELS}`;


            // æ–°å¢: é€é JavaScript ç¶å®šé–‹å§‹æŒ‰éˆ•çš„é»æ“Šäº‹ä»¶ï¼Œè§£æ±ºæ½›åœ¨çš„é»æ“Šå•é¡Œ
            const startButton = document.getElementById('startButton');
            if (startButton) {
                // ä¿®æ­£ã€Œç„¡æ³•é»é–‹å§‹éˆ•ã€çš„å•é¡Œ
                startButton.addEventListener('click', initGame);
            }
        };

    </script>
</body>
</html>